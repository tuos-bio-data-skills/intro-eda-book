# Vectors

## Introduction

This chapter has three goals. First, we want to learn how to work with something called a **vector**, one of the basic structures used to represent data in R-land. Second, we'll learn how to work with vectors by using **numeric** vectors to perform simple calculations. Finally, we'll introduce a couple of different kinds of vectors---**character** vectors and **logical** vectors. This will provide a foundation for working with real data sets in the next block.

::: {.infobox .information data-latex="{information}"}
#### Data structures? {.unnumbered}

The term 'data structure' is used to describe conventions or rules for organising and storing data on a computer. Computer languages use many different kinds of data structures. Fortunately, we only need to learn about a couple of relatively simple ones to use R for data analysis: 'vectors' and 'data frames'. This chapter will consider vectors. The next chapter will look at collections of vectors (a.k.a. data frames).
:::

## Atomic vectors

We'll start with a definition, even though it probably won't make much sense initially: a **vector** is a 1-dimensional data structure for storing a set of values, each accessible by its position in the vector. The simplest kind of vectors in R are called **atomic vectors**[^numeric_vectors-1].

[^numeric_vectors-1]: The other common vector is called a "list". Lists are very useful but we won't cover them in this book.

There are a few different kinds of atomic vector, but the defining feature of each one is that it can only contain data of one 'type'. An atomic vector might contain all integers (e.g. 2, 4, 6, ...) or all characters (e.g. "A", "B", "C"), but it can't mix and match integers and characters (e.g. "A", 2, "C", 5).

The word "atomic" in the name refers to the fact that an atomic vector can't be broken down into anything simpler---they are the simplest kind of data structure R knows about. Even if we're working with a single number we're actually dealing with an atomic vector of length one. Here's the very first expression we evaluated in the [Introduction to R chapter](#r-calculator):

```{r}
1 + 1
```

Look at the output. What is that `[1]` at the beginning? It's actually a clue that the output resulting from `1 + 1` is an atomic vector. We can verify this with the `is.atomic` functions. First we make a variable called `x` with the result of the `1 + 1` calculation:

```{r}
x <- 1 + 1
x
```

Then verify to see if `x` is 'atomic':

```{r}
is.atomic(x)
```

Atomic vectors really are the simplest kind of data structure in R. Unlike many other languages there is simply no way to represent just a number. Instead, a single number must be stored as a vector of length one[^numeric_vectors-2].

[^numeric_vectors-2]: The same is true for things like sets of characters (`"dog"`, `"cat"`, `"fish"`, ...) and logical values (`TRUE` or `FALSE`) discussed in the next two chapters.

## Numeric vectors {#intro-vectors}

A lot of work in R involves **numeric vectors**. After all, data analysis is all about numbers. Here's one simple way to construct a numeric vector (and print it out):

```{r}
numvec <- numeric(length = 50)
numvec
```

What happened? We made a numeric vector with 50 **elements**, each of which is the number 0. The word "element" is used to reference an object (a number in this case) that resides at a particular position in a vector.

When we create a vector but don't assign it to a name using `<-` R just prints it for us. Notice what happens when a vector is printed to the screen. Since a length-50 vector can't fit on one line, it was printed over two. At the beginning of each line there is a `[X]`: the `X` gives the position of the element shown at the beginning of a particular line.

If we need to check that we really have made a numeric vector we can use the `is.numeric`[^numeric_vectors-3] function to do this:

[^numeric_vectors-3]: This may not look like the most useful function in the world, but sometimes we need functions like `is.numeric` to understand what R is doing or root out mistakes in our scripts.

```{r}
is.numeric(numvec)
```

This confirms `numvec` is numeric by returning `TRUE` (a value of `FALSE` would mean that `numvec` is some other kind of object).

Keep in mind that R won't always print the exact values of the elements of a vector. For example, when we print a numeric vector it only prints the elements to 7 significant figures by default. We can see this by printing the built in constant `pi` to the Console:

```{r}
pi
```

The actual value stored in `pi` is much more precise than this. We can see this by printing `pi` again using the `print` function:

```{r}
print(pi, digits = 16)
```

::: {.infobox .information data-latex="{information}"}
#### Different kinds of numbers {.unnumbered}

Roughly speaking, R stores numbers in two different ways depending of whether they are whole numbers ("integers") or numbers containing decimal points ("doubles" -- don't ask). We're not going to worry about this difference. Most of the time the distinction is invisible to users so it is easier to just think in terms of numeric vectors. We can mix and match integers and doubles in R without having to worry too much about how R is storing the numbers.
:::

## Constructing numeric vectors

We just saw to make a numeric vector of zeros using the `numeric` function. This is arguably not a particularly useful skill because we usually need to work vectors of particular values (not just 0). A useful function for creating custom vectors is the `c` function. Take a look at this example:

```{r}
c(1.1, 2.3, 4.0, 5.7)
```

The 'c' in the function name stands for 'combine'. The `c` function takes a variable number of arguments, each of which must be a vector of some kind, and combines these into a single vector. We supplied the `c` function with four arguments, each of which was a vector of length 1 (remember: a single number is treated as a length-one vector). The `c` function combines these to generate a vector of length 4. Simple.

Now look at this example:

```{r}
vec1 <- c(1.1, 2.3)
vec2 <- c(4.0, 5.7, 3.6)
c(vec1, vec2)
```

This shows that we can use the `c` function to combine two or more vectors of any length. We combined a length-2 vector with a length-3 vector to produce a new length-5 vector.

::: {.infobox .information data-latex="{information}"}
#### The `c` function is odd {.unnumbered}
Notice that we did not have to name the arguments in those two examples---there were no `=` involved. The `c` function is an example of one of those flexible functions that breaks the simple rules of thumb for using arguments that we set out earlier: it can take a variable number of arguments and these arguments do not have predefined names. This behaviour is necessary for `c` to be of any use: in order to be useful it needs to be flexible enough to take any combination of arguments.
:::

## Named vectors

What happens if use named arguments with `c`? Take a look at this:

```{r}
namedv <- c(a = 1, b = 2, c = 3)
namedv
```

What happened? The argument names were used to define the names of each element in the vector we made. The resulting vector is still a 1-dimensional data structure. When it is printed to the Console the value of each element is printed along with its associated name above it. We can extract the names from a named vector using the `names` function:

```{r}
names(namedv)
```

Being able to name the elements of a vector is very useful because it allows us to more easily identify relevant information and extract the bits we need---we'll see how this works in the next chapter.

## Vectorised operations

All the simple arithmetic operators (e.g. `+` and `-`) and many mathematical functions are **vectorised** in R. When we use a vectorised function it operates on vectors on an element-by-element basis. We'll make a couple of simple vectors to illustrate what we mean:

```{r}
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
x
```

```{r}
y <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
y
```

This constructed two length-10 numeric vectors, called `x` and `y`, where `x` is a sequence from 1 to 6 and `y` is a sequence from 0.1 to 0.6. `x` and `y` are the same length. Now look at what happens when we add these using `+`:

```{r}
x + y
```

When R evaluates the expression `x + y` it does this by adding the first element of `x` to the first element of `y`, the second element of `x` to the second element of `y`, and so on, working through all 10 elements of `x` and `y`. That's what is meant by a **vectorised** operation.

Vectorisation is implemented in all the standard mathematical functions. For example, our friend the `round` function will round each element of a numeric vector to the nearest integer by default:

```{r}
round(y)
```

The same behaviour is seen with other mathematical functions like `sin`, `cos`, `exp`, and `log`---they apply the relevant function to each element of a numeric vector.

It is important to realise that not all functions are vectorised. For example, the `sum` function takes a vector of numbers and adds them up:

```{r}
sum(y)
```

Although `sum` obviously works on a numeric vector it is not "vectorised" in the sense that it works element-by-element to return an output vector of the same length as its main argument. It just returns a single number--the sum total of the elements of its input.

::: {.infobox .information data-latex="{information}"}
#### Vectorisation is not the norm {.unnumbered}

R's vectorised behaviour may seem like the "obvious" thing to do, but most computer languages do not work like this. In other languages we typically have to write a much more complicated expression to do something so simple. This is one of the reasons R is such a data analysis language: vectorisation allows us to express repetitious calculations in a simple, intuitive way. This behaviour can save us a lot of time. However, not every function treats its arguments in a vectorised way, so we always need to check (most easily, by experimenting) whether this behaviour is available before relying on it.
:::

## Other kinds of atomic vectors {#other-vectors}

The data we collect and analyse are often in the form of numbers, so it comes as no surprise that we work with numeric vectors a lot in R. Nonetheless, we also sometimes need to represent other kinds of vectors, either to represent different types of data, or to help us manipulate our data. This chapter introduces two new types of atomic vector to help us do this: character vectors and logical vectors.

### Character vectors

The elements of **character vectors** are what are known as a "character string" (or "string" if we are feeling lazy). The term "character string" refers a sequence of characters, such as "Treatment 1", "University of Sheffield", "Population Density". A character vector is an atomic vector that stores an ordered collection of one or more character strings.

If we want to construct a character vector in R we have to place double (`"`) or single (`'`) quotation marks around the characters. For example, we can print the name "Dylan" to the Console like this:

```{r}
"Dylan"
```

Notice the `[1]`. This shows that what we just printed is an atomic vector of some kind. We know it's a character vector because the output is printed with double quotes around the value. We often need to make simple character vectors containing only one value---for example, to set the values of arguments to a function.

The quotation marks are not optional---they tell R we want to treat whatever is inside them as a literal value. The quoting is important. If we try to do the same thing as above without the quotes we end up with an error:

```{r, error=TRUE}
Dylan
```

What happened? When the interpreter sees the word `Dylan` without quotes it assumes that this must be the name of a variable, so it goes in search of it in the global environment. We haven't made a variable called Dylan, so there is no way to evaluate the expression and R spits out an error to let us know there's a problem.

Longer character vectors are typically constructed to represent data of some kind. The `c` function is often a good starting point for this kind of thing:

```{r}
# make a length-3 character vector
my_name <- c("Dylan", "Zachary", "Childs")
my_name
```

Here we made a length-3 character vector, with elements corresponding to a first name, middle name, and last name. If we want to extract one or more elements from a character vector by their position

Take note, this is **not** equivalent to the above :

```{r}
my_name <- c("Dylan Zachary Childs")
my_name
```

The only element of this character vector is a single character string containing the first, middle and last name separated by spaces. We didn't even need to use the the `c` function here because we were only ever working with a length-1 character vector. i.e. we could have typed `"Dylan Zachary Childs"` and we would have ended up with exactly the same text printed at the Console.

### Logical vectors

The elements of **logical vectors** only take two values: `TRUE` or `FALSE`. Don't let the simplicity of logical vectors fool you. They're very useful. As with other kinds of atomic vectors the `c` function can be used to construct a logical vector:

```{r}
l_vec <- c(TRUE, FALSE)
l_vec
```

So why are logical vectors useful? Their allow us to represent the results of questions such as, "is x greater than y" or "is x equal to y". The results of such comparisons may then be used to carry out various kinds of subsetting operations.

Let's first look at how we use logical vectors to evaluate comparisons. Before we can do that though we need to introduce **relational operators**. These sound fancy, but they are very simple: we use relational operators to evaluate the relative value of vector elements. Six are available in R:

-   `x < y`: is x less than y?
-   `x > y`: is x greater than y?
-   `x <= y`: is x less than or equal to y?
-   `x >= y`: is x greater than or equal to y?
-   `x == y`: is x equal to y?
-   `x != y`: is x not equal to y?

The easiest way to understand how these work is to simply use them. We need a couple of numeric variables first:

```{r}
x <- c(11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
y <- c(3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
x
y
```

Now, if we need to evaluate and represent a question like, "is x greater than than y", we can use either `<` or `>`:

```{r}
x > y
```

The `x > y` expression produces a logical vector, with `TRUE` values associated with elements in `x` are less than `y`, and `FALSE` otherwise. In this example, x is less than y until we reach the value of 15 in each sequence. Notice too that relational operators are vectorised: they work on an element by element basis.

What does the `==` operator do? It compares the elements of two vectors to determine if they are exactly equal:

```{r}
x == y
```

The output of this comparison is true only for one element, the number 15, which is at the 5^th^ position in both `x` and `y`. The `!=` operator is essentially the opposite of `==`. It identifies cases where two elements are not exactly equal. We could step through each of the different the other relational operators, but hopefully they are self-explanatory at this point (if not, experiment with them).

::: {.infobox .warning data-latex="{warning}"}
#### `=` and `==` are not the same {.unnumbered}
If we want to test for equivalence between the elements of two vectors we must use double equals (`==`), not single equals (`=`). Forgetting to do this `==` instead of `=` is a very common source of mistakes. The `=` symbol already has a use in R---assigning name-value pairs---so it can't also be used to compare vectors because this would lead to ambiguity in our R scripts. Using `=` when you meant to use `==` is a very common mistake. If you make it, this will lead to all kinds of difficult-to-comprehend problems with your scripts. Try to remember the difference!
:::
